#ifndef CANDIDATES_HEAP_HEADER
#define CANDIDATES_HEAP_HEADER

#include "common.comp"

shared ScoredPoint candidates[CANDIDATES_HEAP_CAPACITY];
uint candidates_count;

#define BHEAP_NAME candidates_heap
#define BHEAP_DATA candidates
#define BHEAP_TYPE ScoredPoint
#define BHEAP_CMP(a, b) a.score > b.score
#include "bheap.comp"

void candidates_heap_init() {
    candidates_count = 0;
    BHEAP(candidates_heap, init)(CANDIDATES_HEAP_CAPACITY, 0);
}

ScoredPoint pop_candidate() {
    if (candidates_count == 0) {
        return ScoredPoint(0, 0.0);
    }

    ScoredPoint scored_point = ScoredPoint(0, 0.0);
    if (gl_SubgroupInvocationID == 0) {
        scored_point = BHEAP(candidates_heap, pop)();
    }
    candidates_count--;
    return ScoredPoint(
        subgroupBroadcast(scored_point.id, 0),
        subgroupBroadcast(scored_point.score, 0)
    );
}

bool push_candidate(ScoredPoint scored_point) {
    if (candidates_count == CANDIDATES_HEAP_CAPACITY) {
        ScoredPoint min_scored_point = ScoredPoint(0, positive_infinity);
        uint min_index = 0;
        for (uint i = gl_SubgroupInvocationID; i < candidates_count; i += SUBGROUP_SIZE) {
            if (candidates[i].score < min_scored_point.score) {
                min_scored_point = candidates[i];
                min_index = i;
            }
        }

        float subgroup_smallest = subgroupMin(min_scored_point.score);
        bool is_min_thread = min_scored_point.score == subgroup_smallest;
        uvec4 subgroup_min_threads = subgroupBallot(is_min_thread);
        uint subgroup_min_thread = subgroupBallotFindLSB(subgroup_min_threads);
        min_index = subgroupShuffle(min_index, subgroup_min_thread);
        
        if (subgroupElect()) {
            candidates[min_index] = scored_point;
            BHEAP(candidates_heap, sift_up)(min_index);
        }
    } else {
        if (subgroupElect()) {
            BHEAP(candidates_heap, push)(scored_point);
        }
        candidates_count++;
    }
    return true;
}

#endif
