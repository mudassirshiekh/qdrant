#ifndef CANDIDATES_HEAP_HEADER
#define CANDIDATES_HEAP_HEADER

#include "common.comp"

shared ScoredPoint candidates[CANDIDATES_HEAP_CAPACITY];
uint candidates_count;

#define BHEAP_NAME candidates_heap
#define BHEAP_DATA candidates
#define BHEAP_TYPE ScoredPoint
#define BHEAP_CMP(a, b) a.score < b.score
#include "bheap.comp"

void candidates_heap_init() {
    candidates_count = 0;
    BHEAP(candidates_heap, init)(CANDIDATES_HEAP_CAPACITY, 0);
}

ScoredPoint pop_candidate() {
    if (candidates_count == 0) {
        return ScoredPoint(0, 0.0);
    }

    ScoredPoint max_scored_point = ScoredPoint(0, negative_infinity);
    uint max_index = 0;
    for (uint i = gl_SubgroupInvocationID; i < candidates_count; i += SUBGROUP_SIZE) {
        if (candidates[i].score > max_scored_point.score) {
            max_scored_point = candidates[i];
            max_index = i;
        }
    }

    float subgroup_largest = subgroupMax(max_scored_point.score);
    bool is_max_thread = max_scored_point.score == subgroup_largest;
    uvec4 subgroup_max_threads = subgroupBallot(is_max_thread);
    uint subgroup_max_thread = subgroupBallotFindLSB(subgroup_max_threads);
    max_index = subgroupShuffle(max_index, subgroup_max_thread);

    ScoredPoint popped_value = ScoredPoint(0, 0.0);
    BHEAP(candidates_heap, size)--;
    candidates_count--;
    if (gl_SubgroupInvocationID == 0) {
        popped_value = candidates[max_index];
        candidates[max_index] = candidates[candidates_count];
        BHEAP(candidates_heap, sift_up)(max_index);
    }

    return ScoredPoint(
        subgroupBroadcast(popped_value.id, 0),
        subgroupBroadcast(popped_value.score, 0)
    );
}

bool push_candidate(ScoredPoint scored_point) {
    if (candidates_count == CANDIDATES_HEAP_CAPACITY) {
        if (scored_point.score > BHEAP(candidates_heap, top)().score) {
            if (subgroupElect()) {
                BHEAP(candidates_heap, change_top)(scored_point);
            }
        }
    } else {
        if (subgroupElect()) {
            BHEAP(candidates_heap, push)(scored_point);
        }
        candidates_count++;
    }
    return true;
}

#endif
