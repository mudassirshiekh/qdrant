/******
Shader binary heap.

Usage example.
Step 1: defines

#define BHEAP_NAME bheap // provide binary heap name. Name is required for cases when there are many binary heaps in one shader
float heap_data[8]; // reserve storage for binary heap
#define BHEAP_DATA heap_data // provide storage name
#define BHEAP_TYPE float // binary tree element type
#define BHEAP_CMP(a, b) a > b // cmp function
#include "bheap.comp" // define all binary tree functions

Step 2: init
BHEAP(BHEAP_NAME, init)(8, 0); // capacity and offset in storage

Step 3: usage
BHEAP(BHEAP_NAME, capacity) // get capacity
BHEAP(BHEAP_NAME, offset) // get offset
BHEAP(BHEAP_NAME, size); // get size
BHEAP(BHEAP_NAME, top)(); // get top value
BHEAP(BHEAP_NAME, pop)(); // pop value
BHEAP(BHEAP_NAME, change_top)(1.0); // pop and push
BHEAP(BHEAP_NAME, push)(1.0); // push value
BHEAP(BHEAP_NAME, into_array)(); // convert to sorted array and return array size

******/

#ifndef BHEAP_HEADER
#define BHEAP_HEADER

#include "common.comp"

shared ScoredPoint bheap[BHEAP_CAPACITY];

// swap
void bheap_swap(uint offset, uint i, uint j) {
    ScoredPoint tmp = bheap[offset + i];
    bheap[offset + i] = bheap[offset + j];
    bheap[offset + j] = tmp;
}

// compare, call BHEAP_CMP function
bool bheap_cmp(uint offset, uint i, uint j) {
    return bheap[offset + i].score < bheap[offset + j].score;
}

// sift down
void bheap_sift_down(uint offset, uint size, uint i) {
    while (2 * i + 1 < size) {
        uint left = 2 * i + 1;
        uint right = 2 * i + 2;
        uint j = left;
        if (right < size && bheap_cmp(offset, right, left)) {
            j = right;
        }
        if (bheap_cmp(offset, i, j)) {
            break;
        }
        bheap_swap(offset, i, j);
        i = j;
    }
}

void bheap_sift_up(uint offset, uint i) {
    while (i > 0 && bheap_cmp(offset, i, (i - 1) / 2)) {
        bheap_swap(offset, i, (i - 1) / 2);
        i = (i - 1) / 2;
    }
}

// push
bool bheap_push(uint offset, in out uint size, uint capacity, ScoredPoint score) {
    uint i = size;
    size++;
    if (subgroupElect()) {
        bheap[offset + i] = score;
        bheap_sift_up(offset, i);
    }
    return true;
}

// get top value
ScoredPoint bheap_top(uint offset) {
    return bheap[offset];
}

// pop value
ScoredPoint bheap_pop(uint offset, in out uint size) {
    ScoredPoint top_value = bheap_top(offset);
    size--;
    if (subgroupElect()) {
        bheap[offset] = bheap[offset + size];
        bheap_sift_down(offset, size, 0);
    }
    return top_value;
}

// replace top value
void bheap_change_top(uint offset, uint size, ScoredPoint new_value) {
    if (subgroupElect()) {
        bheap[offset] = new_value;
        bheap_sift_down(offset, size, 0);
    }
}

// into_array
uint bheap_into_array(uint offset, in out uint size) {
    uint array_size = size;
    while (size > 0) {
        uint i = size - 1;
        ScoredPoint value = bheap_pop(offset, size);
        if (subgroupElect()) {
            bheap[offset + i] = value;
        }
    }
    return array_size;
}

#endif
