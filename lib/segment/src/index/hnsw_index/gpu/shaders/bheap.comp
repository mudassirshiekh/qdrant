#ifndef BHEAP_HEADER
#define BHEAP_HEADER

#include "common.comp"

shared ScoredPoint bheap[BHEAP_CAPACITY];

// swap
void bheap_swap(uint offset, uint i, uint j) {
    ScoredPoint tmp = bheap[offset + i];
    bheap[offset + i] = bheap[offset + j];
    bheap[offset + j] = tmp;
}

// compare, call BHEAP_CMP function
bool bheap_cmp(uint offset, uint i, uint j) {
    return bheap[offset + i].score < bheap[offset + j].score;
}

// sift down
void bheap_sift_down(uint offset, uint size, uint i) {
    while (2 * i + 1 < size) {
        uint left = 2 * i + 1;
        uint right = 2 * i + 2;
        uint j = left;
        if (right < size && bheap_cmp(offset, right, left)) {
            j = right;
        }
        if (bheap_cmp(offset, i, j)) {
            break;
        }
        bheap_swap(offset, i, j);
        i = j;
    }
}

void bheap_sift_up(uint offset, uint i) {
    while (i > 0 && bheap_cmp(offset, i, (i - 1) / 2)) {
        bheap_swap(offset, i, (i - 1) / 2);
        i = (i - 1) / 2;
    }
}

// get top value
ScoredPoint bheap_top(uint offset) {
    return bheap[offset];
}

// replace top value
void bheap_change_top(uint offset, uint size, ScoredPoint new_value) {
    if (subgroupElect()) {
        bheap[offset] = new_value;
        bheap_sift_down(offset, size, 0);
    }
}

// push
bool bheap_push(uint offset, in out uint size, uint capacity, ScoredPoint score) {
    if (size == capacity) {
        if (score.score > bheap[offset].score) {
            bheap_change_top(offset, capacity, score);
            return true;
        } else {
            return false;
        }
    } else {
        uint i = size;
        size++;
        if (subgroupElect()) {
            bheap[offset + i] = score;
            bheap_sift_up(offset, i);
        }
        return true;
    }
}

// pop value
ScoredPoint bheap_pop(uint offset, in out uint size) {
    ScoredPoint top_value = bheap_top(offset);
    size--;
    if (subgroupElect()) {
        bheap[offset] = bheap[offset + size];
        bheap_sift_down(offset, size, 0);
    }
    return top_value;
}

ScoredPoint bheap_pop_max(uint offset, in out uint size) {
    if (size == 0) {
        return ScoredPoint(0, 0.0);
    }

    ScoredPoint max_scored_point = ScoredPoint(0, negative_infinity);
    uint max_index = 0;
    uint scan_start = (size - 1) / 2;
    for (uint i = scan_start + gl_SubgroupInvocationID; i < size; i += SUBGROUP_SIZE) {
        if (bheap[offset + i].score > max_scored_point.score) {
            max_scored_point = bheap[offset + i];
            max_index = i;
        }
    }

    float subgroup_largest = subgroupMax(max_scored_point.score);
    bool is_max_thread = max_scored_point.score == subgroup_largest;
    uvec4 subgroup_max_threads = subgroupBallot(is_max_thread);
    uint subgroup_max_thread = subgroupBallotFindLSB(subgroup_max_threads);
    max_index = subgroupShuffle(max_index, subgroup_max_thread);

    ScoredPoint popped_value = bheap[offset + max_index];
    if (subgroupElect()) {
        bheap[offset + max_index] = bheap[offset + size - 1];
        bheap_sift_up(offset, max_index);
    }
    size--;

    return popped_value;
}

// into_array
uint bheap_into_array(uint offset, in out uint size) {
    uint array_size = size;
    while (size > 0) {
        uint i = size - 1;
        ScoredPoint value = bheap_pop(offset, size);
        if (subgroupElect()) {
            bheap[offset + i] = value;
        }
    }
    return array_size;
}

#endif
