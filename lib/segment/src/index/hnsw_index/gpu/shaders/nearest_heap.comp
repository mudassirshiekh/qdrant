#ifndef NEAREST_HEAP_HEADER
#define NEAREST_HEAP_HEADER

#include "common.comp"

shared ScoredPoint nearest[NEAREST_HEAP_CAPACITY];

#define BHEAP_NAME nearest_heap
#define BHEAP_DATA nearest
#define BHEAP_TYPE ScoredPoint
#define BHEAP_CMP(a, b) a.score < b.score
#include "bheap.comp"

uint nearest_count;

void nearest_heap_init() {
    nearest_count = 0;
    BHEAP(nearest_heap, init)(NEAREST_HEAP_CAPACITY, 0);
}

// Push the nearest `ScoredPoint`. Returns true if the `ScoredPoint` was added.
bool push_nearest(ScoredPoint scored_point) {
    if (nearest_count == NEAREST_HEAP_EF) {
        if (scored_point.score > BHEAP(nearest_heap, top)().score) {
            if (subgroupElect()) {
                BHEAP(nearest_heap, change_top)(scored_point);
            }
            return true;
        } else {
            return false;
        }
    } else {
        if (subgroupElect()) {
            BHEAP(nearest_heap, push)(scored_point);
        }
        nearest_count++;
        return true;
    }
}

uint subgroup_bubble_sort(float score) {
    uint invocation = gl_SubgroupInvocationID;
    bool is_even = invocation % 2 == 0;
    uint invocation_forward = is_even ? invocation + 1 : invocation - 1;
    uint invocation_backward = invocation;
    if (invocation != SUBGROUP_SIZE - 1 && invocation != 0) {
        invocation_backward = is_even ? invocation - 1 : invocation + 1;
    }

    uint index = invocation;
    for (uint j = 0; j < SUBGROUP_SIZE / 2; j++) {
        bool is_even = gl_SubgroupInvocationID % 2 == 0;
        bool was_changed = false;

        // step one: compare with the next element
        {
            float next_score = subgroupShuffle(score, invocation_forward);
            uint next_index = subgroupShuffle(index, invocation_forward);
            bool need_exchange = is_even ? score < next_score : score > next_score;
            if (need_exchange) {
                was_changed = true;
                score = next_score;
                index = next_index;
            }
        }

        // step two: compare with previous element
        {
            float next_score = subgroupShuffle(score, invocation_backward);
            uint next_index = subgroupShuffle(index, invocation_backward);
            bool need_exchange = is_even ? score > next_score : score < next_score;
            if (need_exchange) {
                was_changed = true;
                score = next_score;
                index = next_index;
            }
        }

        if (!subgroupAny(was_changed)) {
            break;
        }
    }
    return index;
}

void sort_nearest_bubble() {
    uint iterations_count = nearest_count / (SUBGROUP_SIZE / 2) + uint(sign(float(nearest_count % (SUBGROUP_SIZE / 2))));
    for (uint _cnt = 0; _cnt < iterations_count; _cnt++) {
        // do bubble sort in each subgroup to reduce the number of memory accesses
        for (uint i = gl_SubgroupInvocationID; i < NEAREST_HEAP_CAPACITY; i += SUBGROUP_SIZE) {
            ScoredPoint scored_point = nearest[i];

            if (i >= nearest_count) {
                scored_point.score = negative_infinity;
            }
            uint permut = subgroup_bubble_sort(scored_point.score);
            float shuffled_scored_point_score = subgroupShuffle(scored_point.score, permut);
            uint shuffled_scored_point_id = subgroupShuffle(scored_point.id, permut);
            nearest[i] = ScoredPoint(shuffled_scored_point_id, shuffled_scored_point_score);
            subgroupMemoryBarrierShared();
        }

        if (NEAREST_HEAP_CAPACITY > SUBGROUP_SIZE) {
            // do bubble sort in each subgroup to reduce the number of memory accesses
            for (uint i = gl_SubgroupInvocationID + (SUBGROUP_SIZE / 2); i < NEAREST_HEAP_CAPACITY - (SUBGROUP_SIZE / 2); i += SUBGROUP_SIZE) {
                ScoredPoint scored_point = nearest[i];
                
                if (i >= nearest_count) {
                    scored_point.score = negative_infinity;
                }
                uint permut = subgroup_bubble_sort(scored_point.score);
                float shuffled_scored_point_score = subgroupShuffle(scored_point.score, permut);
                uint shuffled_scored_point_id = subgroupShuffle(scored_point.id, permut);
                nearest[i] = ScoredPoint(shuffled_scored_point_id, shuffled_scored_point_score);
                subgroupMemoryBarrierShared();
            }
        }
    }
}

void bitonic_cmp(uint i, uint j) {
    uint b_i = i;
    uint b_j = j;
    if (i < j && j < nearest_count && nearest[b_j].score > nearest[b_i].score) {
        ScoredPoint temp = nearest[b_i];
        nearest[b_i] = nearest[b_j];
        nearest[b_j] = temp;
    }
}

void sort_nearest() {
    for (uint group_offset = 0; group_offset < nearest_count; group_offset += SUBGROUP_SIZE) {
        ScoredPoint scored_point = ScoredPoint(0, negative_infinity);
        uint i = group_offset + gl_SubgroupInvocationID;
        if (i < nearest_count) {
            scored_point = nearest[i];
        }

        uint permut = subgroup_bubble_sort(scored_point.score);
        scored_point = ScoredPoint(
            subgroupShuffle(scored_point.id, permut),
            subgroupShuffle(scored_point.score, permut)
        );

        if (i < nearest_count) {
            nearest[i] = scored_point;
        }
    }

    for (uint k = 64; (k >> 1) < nearest_count; k <<= 1) {
        for (uint i = gl_SubgroupInvocationID; i < nearest_count; i += SUBGROUP_SIZE) {
            bitonic_cmp(i, i ^ (k - 1));
        }
        subgroupMemoryBarrierShared();

        for (uint j = k >> 1; 0 < j; j >>= 1) {
            for (uint i = gl_SubgroupInvocationID; i < nearest_count; i += SUBGROUP_SIZE) {
                bitonic_cmp(i, i ^ j);
            }
            subgroupMemoryBarrierShared();
        }
    }
}

ScoredPoint get_nearest(uint i) {
    return nearest[i];
}

void set_nearest(uint i, ScoredPoint scored_point) {
    if (subgroupElect()) {
        nearest[i] = scored_point;
    }
    subgroupMemoryBarrierShared();
}

#endif
